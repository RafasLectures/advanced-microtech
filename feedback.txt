Very nice exercise!

I struggled with memory. I used initially my own library that I wrote in the Microcontroller course (https://github.com/RafasLectures/microtech),
but I ran into problems when writing the example code. I then found an external library and asked Jan if I could use it,
and I was allowed to. This helped a lot, but still now my code has a size of 0x74a and there is 0x7de available.
So I am using pretty much all the memory, but I want to figure out why, since I have a lot of code that is computed in
compile time.

I did some investigation already and I saw in godbolt (link and code below) that passing some arguments by reference generated some overhead.
So I will probably dig a little bit there to see if I can optimize more my code.

But in general it was a very nice exercise.

From the previous topic in godbolt. Just take the code below and paste it in there. One can see the assembly generated, and the function
"encode" is much smaller in instruction size compared to encodeRef.
The url of godbolt is https://godbolt.org/

Code:

#include <cstring>
#include <iostream>
#include <type_traits>
#include <limits>
#include <ios>

template<typename FIELD_TYPE, typename FRAME_TYPE, FRAME_TYPE mask, FRAME_TYPE position>
class Field {
  static_assert(std::is_integral<FRAME_TYPE>::value, "Frame type is not integral");
  static_assert(std::numeric_limits<FRAME_TYPE>::digits > position, "Position shift bigger than value coming");

public:
  /**
   * Method to decode a field within a frame.
   * @param value The raw value of the frame
   * @return The decoded value.
   */
  static constexpr FIELD_TYPE decode(const FRAME_TYPE value) {
    return static_cast<FIELD_TYPE>((value & mask) >> position);
  }

  /**
   * Method to encode the field into the frame to be send.
   *
   * @param value [output] The frame will be populated with the encoded value.
   * @param toEncode Value to encode from the field type
   * @return void
   */
  static constexpr FRAME_TYPE encode(FRAME_TYPE value, FIELD_TYPE toEncode) {
    const FRAME_TYPE shiftedValue = static_cast<FRAME_TYPE>(toEncode) << position;
        value &= ~mask;
        value |= shiftedValue;
        return value;
  }

  static constexpr void encodeRef(FRAME_TYPE& value, FIELD_TYPE toEncode) {
    const FRAME_TYPE shiftedValue = static_cast<FRAME_TYPE>(toEncode) << position;
        value &= ~mask;
        value |= shiftedValue;
  }

  static constexpr FRAME_TYPE MASK = mask;
  static constexpr FRAME_TYPE POSITION = position;
};

static constexpr Field<uint16_t, uint16_t, 0x0003, 0> test;

int main() {
    uint16_t testVal = 0x0F;
    test.encode(testVal, 0x02);
    std::cout << "encode: " <<std::hex << testVal << '\n';

    test.encodeRef(testVal, 0x01);
    std::cout << "encode: " << std::hex << testVal << '\n';
    return 0;
}